pipeline {
    agent none
    environment {
        GIT_URL = 'https://github.com/christus2024/mkutano-frontend.git'
        GIT_CREDENTIAL_ID = 'github_mkutano_project_token'
        TZ = 'Europe/Paris'
        POM_FILE = 'pom.xml'
        RELEASE_VERSION_FILE = 'versions.txt' // Nom du fichier pour stocker les versions
        DOCKER_IMAGE = ''
    }
    parameters {
            string(name: 'releaseVersion', defaultValue: "${params[releaseVersion]}", description: 'Version de release', trim: true)
            string(name: 'snapshotVersion', defaultValue: "${params[snapshotVersion]}",description: 'Version de snapshot', trim: true)
            booleanParam(name:'isRelease', defaultValue: false, description: 'Build de release ?')
    }
    //Valid option types for options: [authorizationMatrix, buildDiscarder, catchError, checkoutToSubdirectory, disableConcurrentBuilds,
     //disableRestartFromStage, disableResume, dockerNode, durabilityHint, githubProjectProperty, newContainerPerStage,
      //overrideIndexTriggers, parallelsAlwaysFailFast, preserveStashes, quietPeriod, rateLimitBuilds, retry, script,
      //skipDefaultCheckout, skipStagesAfterUnstable, timeout, timestamps, waitUntil, warnError, withChecks, withContext,
     //withCredentials, withEnv, wrap, ws]
    options{
        timestamps()
        buildDiscarder(logRotator(numToKeepStr: '5'))
    }

    stages {
        stage('Validate inputs') {
            agent any
            steps {
                script {
                    try{
                        if (params.isRelease && (!params.releaseVersion || !params.snapshotVersion)) {
                            error "Les versions de release et de snapshot sont nécessaires pour un build de release."
                            currentBuild.result = 'FAILURE'
                        }
                        sh 'git status'
                        sh 'git branch'
                        echo "releaseVersion:  ${params.releaseVersion}"
                        echo "snapshotVersion:  ${params.snapshotVersion}"
                        echo "isRelease:  ${params.isRelease}"

                    } catch(error){
                        error("erreur lors de la validation des inputs: ${error}")
                        currentBuild.result = 'FAILURE'
                    }
                }

            }
        }
        stage('Checkout project') {
            agent any
            steps {
                echo "GIT_BRANCH:  ${env.GIT_BRANCH}" // Ajout de 'env.' pour plus de clarté
                echo "BRANCH_NAME:  ${BRANCH_NAME}"
                script{
                    sh 'git config --local user.email christus.tchassi@it4innov.fr'
                    sh 'git config --local user.name christus2024'
                }
                git branch: env.BRANCH_NAME, url: env.GIT_URL, credentialsId: env.GIT_CREDENTIAL_ID

            }
        }

        stage('Test') {
            agent {
                    docker { image 'maven:3.9.3-eclipse-temurin-17'
                        args '-v $HOME/.m2:/root/.m2 -v /var/run/docker.sock:/var/run/docker.sock'
                        }
                }
            steps {
                // Utilisez catchError pour gérer les erreurs de tests et faire echouer la pipeline si les tests echouent
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                    //sh 'mvn clean verify -Ddependency-check.skip=true'  //commande maven permetant de sauter la phase dependancy-check
                    sh 'mvn clean verify'       //plus besoin de sauter cette phase car par defaut j'ai desactiver le plugin dans le pom avec la proprieté skip.dependancy-check
                }
            }
        }
        stage('Check Dependencies') {
            when {
                expression { env.BRANCH_NAME == 'develop' }
            }
            agent {
                    docker { image 'maven:3.9.3-eclipse-temurin-17'
                        args '-v $HOME/.m2:/root/.m2 -v /var/run/docker.sock:/var/run/docker.sock'
                        }
                }
            steps {
                echo "Vérification des dépendances..."
                catchError(buildResult: 'FAILURE', stageResult: 'FAILURE') {
                   sh 'mvn dependency-check:check -Dskip.dependency.check=true' // la proprieté skip.dependency.check permet d'activer le plugin maven pour l'execution du dependancy-check
                }

            }
        }
         stage('Build') {
            agent {
                    docker { image 'maven:3.9.3-eclipse-temurin-17'
                        args '-v $HOME/.m2:/root/.m2 -v /var/run/docker.sock:/var/run/docker.sock'
                        }
                }
            steps {
                script {
                    try{
                        if (params.isRelease) {
                            println 'Construction de la release'
                            // Assure que le HEAD est attaché à la branche cible
                            sh "git checkout ${BRANCH_NAME}"
                            // 1. Modifier la version dans le pom.xml
                            sh "mvn versions:set -DnewVersion=${params.releaseVersion}"

                            // 2. Ajouter et commit le changement de version
                            sh 'git add pom.xml'
                            sh "git commit -m \"[jenkins-commit] Update project version to ${params.releaseVersion}\""

                            /* withCredentials([usernamePassword(credentialsId: env.GIT_CREDENTIAL_ID,
                               usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')]){
                                def encodedPass = URLEncoder.encode(GIT_PASS, "UTF-8")
                                sh "git push http://$GIT_USER:$encodedPass@github.com/christus2024/mkutano-frontend.git ${env.BRANCH_NAME}"
                            } */
                            println 'Écrire la version de la release dans le fichier'
                            echo "Enregistrement de la version de release: ${params.releaseVersion} dans le fichier ${RELEASE_VERSION_FILE}"
                            echo "${params.releaseVersion} >> ${RELEASE_VERSION_FILE}"
                             withCredentials([string(credentialsId: env.GIT_CREDENTIAL_ID, variable: 'GIT_TOKEN')]){
                                sh 'git config --local user.email christus.tchassi@it4innov.fr'
                                sh 'git config --local user.name christus2024'

                               BRANCH_NAME = "${env.BRANCH_NAME}"
                               sh 'git push https://$GIT_TOKEN@github.com/christus2024/mkutano-frontend.git  ' + BRANCH_NAME
                           }
                            // 3. Continuer avec le packaging
                            sh 'mvn  package'
                        } else {
                            //Continuer avec le packaging
                            sh 'mvn  package'
                        }
                        // Archive les fichiers générés
                        stash name: 'code-frontend', includes: '**/*'

                        println 'Construction de la release éffectuée avec succes'
                    } catch (exception){
                        error "Echec du build"
                        currentBuild.result = 'FAILURE'
                    }

                }
            }
         }
        stage('Archive') {
            agent {
                    docker { image 'maven:3.9.3-eclipse-temurin-17'
                        args '-v $HOME/.m2:/root/.m2 -v /var/run/docker.sock:/var/run/docker.sock'
                        }
                }
            steps {
                script {
                    //sh "git checkout -B ${GIT_BRANCH} origin/${GIT_BRANCH}"
                    //sh 'git pull'
                    unstash 'code-frontend' // Copie des fichiers archivés dans le répertoire de travail
                    def profile = params.isRelease ? 'release-profile' : 'snapshot-profile'
                    sh "mvn deploy -P ${profile} --settings ./.m2/settings.xml"
                    // Archive les fichiers générés
                    stash name: 'code-frontend', includes: '**/*'

                }
            }
        }

        stage('Build Docker Image') {
            agent {
                docker {
                    image 'docker:19.03.12-dind'
                    args '-v /var/run/docker.sock:/var/run/docker.sock' // Monter le socket Docker

                 }
            }
            steps {
                script {
                    // Remplacez <your-image-name> et <path-to-dockerfile> par vos valeurs
                    //code-frontend-123.23.12-runner.jar

                    unstash 'code-frontend' // Copie des fichiers archivés dans le répertoire de travail

                    def pom = readMavenPom(file: POM_FILE)
                    def version = params.isRelease ? "${params.releaseVersion}" : "${params.snapshotVersion}"
                    def imageName = params.isRelease ? " ${pom.artifactId}:${params.releaseVersion}" : "${pom.artifactId}:${params.snapshotVersion}"
                    env.DOCKER_IMAGE = imageName
                    println "imageName: ${imageName}"
                    sh "docker build --build-arg VERSION=${version} -t ${imageName} -f dockerfile ."
                    // Archive les fichiers générés
                    stash name: 'code-frontend', includes: '**/*'
                }
            }
        }
        stage('Trivy Scan') {
            agent {
                docker {
                    image 'aquasec/trivy:latest' // Utiliser l'image Trivy
                    args '-v /var/run/docker.sock:/var/run/docker.sock' // Monter le socket Docker
                }
            }
            steps {
                // Exécuter l'analyse Trivy sur l'image Docker construite
                sh "trivy image --exit-code 1 --severity HIGH,CRITICAL ${env.DOCKER_IMAGE}"
            }
        }
        stage('Docker Push') {
              agent any
              steps {
                withCredentials([usernamePassword(credentialsId: 'dockerHub', passwordVariable: 'dockerHubPassword', usernameVariable: 'dockerHubUser')]) {
                  sh "docker login -u ${env.dockerHubUser} -p ${env.dockerHubPassword}"
                  sh 'docker push shanem/spring-petclinic:latest'
                }
              }
            }
        stage('Preparation de la version de dev'){
            agent {
                docker { image 'maven:3.9.3-eclipse-temurin-17'
                    args '-v $HOME/.m2:/root/.m2 -v /var/run/docker.sock:/var/run/docker.sock'
                    }
            }
            steps{
                script{

                    unstash 'code-frontend'
                    sh "git checkout -B ${GIT_BRANCH} origin/${GIT_BRANCH}"
                    println 'Mise à jour de la version de developpement'
                    // 4. Modifier la version dans le pom.xml
                    sh "mvn versions:set -DnewVersion=${params.snapshotVersion}"

                    // 5. Ajouter et commit le changement de version

                    sh 'git add pom.xml'
                    sh "git commit -m \"[jenkins-commit] Update project version to ${params.snapshotVersion}\""

                    /* withCredentials([usernamePassword(credentialsId: 'git-credentials',
                       usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASS')])
                        {def encodedPass = URLEncoder.encode(GIT_PASS, "UTF-8")
                        sh "git push http://$GIT_USER:$encodedPass@github.com/christus2024/mkutano-frontend.git ${env.BRANCH_NAME}" }
                    } */
                    withCredentials([string(credentialsId: env.GIT_CREDENTIAL_ID, variable: 'GIT_TOKEN')]){
                        sh 'git config --local user.email christus.tchassi@it4innov.fr'
                        sh 'git config --local user.name christus2024'
                        BRANCH_NAME = "${env.BRANCH_NAME}"
                        sh 'git push https://$GIT_TOKEN@github.com/christus2024/mkutano-frontend.git  ' + BRANCH_NAME
                   }
                }
            }
        }
    }
    //post {

     //   always {
     //       cleanWs()
     //   }
  //  }
}


// TODO ajouter un utilisateur jenkins au projet
// configurer les profiles snapshot et release pour les pusher les artefacts sur nexus
// Deployer sonar et harbord et configurer l'analyse de qualité
// Installer trivy et configurer l'analyse de vulnerabilité
// installer le plugin owaps dans le code et configurer le scan sur la branche developpement
